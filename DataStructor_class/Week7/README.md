# Week 7
##  Double Linked List
- 이중 연결 리스트는 단방향 연결 리스트의 구조에 이전 노드를 가리키는 previous 포인터를 추가적으로 넣은 연결 리스트이다.

- 단방향 연결 리스트를 사용할 경우에 노드의 삭제, 삽입의 연산을 수행하는 노드가 대상 노드가 아닌 대상 노드의 뒷 노드에서 이루어지는 한계점이 있다.

- 이를 해결하기 위해서 이중 연결 리스트라는 개념이 생성되었다. 이중 연결 리스트는 연산을 수행하는 노드가 대상 노드이므로 단방향 연결 리스트에 있었던 뒷 노드를 구하기 위한 연산이 불필요해진다.

- 노드의 구성은 다음과 같다.

<pre>
<code>
typedef int TYPE;

typedef struct node{
    TYPE data;
    struct node* prev;
    struct node* next;
}Node;

Node* head;
Node* tail;
</code>
</pre>

- ```prev```는 그 노드의 이전 노드를 가리키는 포인터이다.
- ```next```는 단방향 연결 리스트와 같은 개념이다. 그 노드의 다음 노드를 가리키는 포인터이다.

- ```head```는 연결 리스트의 주소를 (정확히는 연결 리스트의 첫 노드의 주소)가지고 있는 포인터이다.

- ```tail```은 연결 리스트의 마지막 노드의 주소를 가지고 있는 포인터이다.

- 이중 연결 리스트의 연산은 코드를 참고하라.

<br>
<br>

## 여러 개의 소스파일을 이용한 프로그래밍
- 프로그램은 간단한 경우에만 하나의 소스 파일로 나타내질 수 있으며 일반적인 프로그램의 경우에는 여러 개의 소스 파일로 하나의 프로그램을 만들게 된다.

- 여러 개의 소스 파일로 분할할 경우에 우리가 해결해야할 문제점은 다음과 같다.
    1. 다른 소스 파일에 정의되어 있는 함수(또는 메크로)를 호출할 수 있는가?

    2. 어떻게 다른 파일에 정의되어있는 변수를 사용할 것인가?

    3. 어떻게 서로 다른 파일들이 매크로나 타입 정의(대표적으로 struct)를 공유할 것인가?

- 위 문제에 대한 해결로는 header file과 include 지시어를 통하여 해결이 가능하다.

- header file에는 함수의 프로토타입, 매크로 정의, 타입 정의를 넣으며 c파일에는 함수의 구현부를 넣는다 이후 사용하는 소스 파일에 include 지시어로 해당 header file을 include하여 사용할 수 있다.

- 아래 소스 코드는 위 동작의 예시를 간략하게 나타내고 있다.

<pre>
<code>
library.h

#define MAX 100
typedef struct song Song;
struct song{
    ...
};

void add_song();
void find_song();
...

===========================================
library.c

void add_song(){
    ...
}

void find_song(){
    ...
}
...

=======================================
main.c

#include "library.h"

int main()
{
    ...
    add_song();
    ...
}

</code>
</pre>

## 변수의 공유
- 변수의 선언과 정의의 구분은 다음과 같다.
    - 선언 : 컴파일러에게 변수의 존재를 알려 주는 역할이다.

    - 정의 : 실제로 그 변수에게 메모리를 할당하는 행위

- 변수의 선언과 정의를 동시에 하는 방법은 우리가 매번 하는 변수 선언과 동일하다.
    - ```int a```로 선언과 정의가 가능하다.

- 변수는 여러번 선언될 수 있으나 정의는 한 번만 되야 한다.

- 키워드 extern을 이용하여 변수를 정의하지 않고 선언만 할 수 있다. 즉 컴파일러에게 변수가 다른 파일에 정의되어 있다 라는 것을 알려줄 수 있다.
    - ex) ```extern int i;```, ```extern int a[10]``` 등등...

- 따라서 변수를 공유하기 위해서는 다음의 과정을 거친다.
    - 공유 변수의 선언은 해더 파일에 둔다.

    - 공유 변수를 사용하는 모든 소스 파일은 해더 파일을 include 한다.

    - 소스 파일 중 오직 한 곳에서 공유 변수를 정의한다. 이는 하나의 해더 파일을 여러 소스 파일에서 사용하더라도 변수 자체는 소스 파일중 하나에서만 정의해야 한다는 것을 의미한다.

## 중첩된 include
- 어떠한 헤더 파일 a.h가 b.h에도 사용되고 c.h에도 필요하다 가정하자. 또한 d.c에 b.h와 c.h가 필요하여 include 한다고 가정한다면 이는 a.h가 중복되어 include된다는 것을 의미한다.

- 이러한 중복 include는 항상 오류인 것은 아니나 타입 정의(struct, etc...)가 중복되는 것은 컴파일 오류를 일으킨다.

- 이러한 중복 include 문제를 해결하기 위해 전처리기 #ifndef - #endif를 사용한다. 사용의 예시는 아래와 같다.

<pre>
<code>
#ifndef BOOLEAN_H
#define BOOLEAN_H

#define TRUE 1
#define FALSE 0
typedef int Bool;

#endif
</code>
</pre>

- 이는 BOOLEAN_H가 정의되어 있지 않다면 아래의 정의를 사용하는 것이고 정의되어 있다면 무시하는 행동을 한다.